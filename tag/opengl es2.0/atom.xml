<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://example.com</id>
    <title>花咲く • Posts by &#34;opengl es2.0&#34; tag</title>
    <link href="http://example.com" />
    <updated>2017-07-12T02:49:46.000Z</updated>
    <category term="Android" />
    <category term="图像处理" />
    <category term="C++" />
    <category term="蓝牙" />
    <category term="系统" />
    <category term="Camera" />
    <category term="Cmake" />
    <category term="音视频" />
    <category term="FFmpeg" />
    <category term="多媒体" />
    <category term="ExoPlayer" />
    <category term="流媒体协议" />
    <category term="HLS" />
    <category term="算法" />
    <category term="LeetCode" />
    <category term="开发" />
    <category term="Mac" />
    <category term="OpenGL ES" />
    <category term="OpenGL ES2.0" />
    <category term="OpenGL ES3.0" />
    <category term="OpenSLES" />
    <category term="插件化" />
    <category term="Dalvik虚拟机" />
    <category term="leetcode" />
    <category term="ffmpeg" />
    <category term="日语" />
    <category term="歌词" />
    <category term="排序算法" />
    <category term="二叉树" />
    <category term="Algorithm" />
    <category term="数据结构" />
    <category term="树" />
    <category term="BFS" />
    <entry>
        <id>http://example.com/2017/07/12/OpenGL-ES2-0%E4%B8%AD%E7%9A%84%E7%BA%B9%E7%90%86/</id>
        <title>OpenGL ES2.0中的纹理</title>
        <link rel="alternate" href="http://example.com/2017/07/12/OpenGL-ES2-0%E4%B8%AD%E7%9A%84%E7%BA%B9%E7%90%86/"/>
        <content type="html">&lt;h1 id=&#34;opengl-中的texture纹理&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#opengl-中的texture纹理&#34;&gt;#&lt;/a&gt; OpenGL 中的 Texture（纹理）&lt;/h1&gt;
&lt;p&gt;翻译自&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL3d3dy5sZWFybm9wZW5nbGVzLmNvbS9hbmRyb2lkLWxlc3Nvbi1mb3VyLWludHJvZHVjaW5nLWJhc2ljLXRleHR1cmluZy8=&#34;&gt; Android 课程 3：基础纹理&lt;/span&gt; 英语好的小伙伴可以直接去这个网站学习 OpenGL ES2&lt;/p&gt;
&lt;h2 id=&#34;纹理介绍&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#纹理介绍&#34;&gt;#&lt;/a&gt; 纹理介绍&lt;/h2&gt;
&lt;p&gt;纹理映射技术是构建一个真实 3D 世界最重要的方式。没有纹理映射的话，所以的东西都是光滑的渐变，看起来像人造的，像是 90 年代的控制台游戏&lt;/p&gt;
&lt;p&gt;首先大量使用了纹理技术的游戏，比如 Doom 和 Duke Nukem 3D，通过添加的视觉影响能极大的增强了游戏的真实性。&lt;/p&gt;
&lt;h2 id=&#34;纹理坐标系&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#纹理坐标系&#34;&gt;#&lt;/a&gt; 纹理坐标系&lt;/h2&gt;
&lt;p&gt;在 OpenGL 中，纹理坐标系使用（s，t）来代替（x，y）坐标，代表纹理上的点，最终映射到几何形上。另外需要注意的是纹理坐标系和其他的 OpenGL 坐标系一样，t（y）轴指向上，因此位置越高值越大。&lt;/p&gt;
&lt;p&gt;[外链图片转存失败，源站可能有防盗链机制，建议将图片保存下来直接上传 (img-AiDSpFC1-1648314308409)(&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL2ltZzQuaW1ndG4uYmRpbWcuY29tL2l0L3U9MjIyNjEzNjg0MywxNjkzMDA3ODk1JmFtcDtmbT0yNiZhbXA7Z3A9MC5qcGc=&#34;&gt;http://img4.imgtn.bdimg.com/it/u=2226136843,1693007895&amp;amp;fm=26&amp;amp;gp=0.jpg&lt;/span&gt;)]&lt;/p&gt;
&lt;h2 id=&#34;纹理映射&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#纹理映射&#34;&gt;#&lt;/a&gt; 纹理映射&lt;/h2&gt;
&lt;p&gt;在这课中注意看 2D 纹理 (GL_TEXTURE_2D)。OpenGL ES 也提供了其他的纹理模型让你做不同和专业的效果。&lt;/p&gt;
&lt;h3 id=&#34;顶点着色器&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#顶点着色器&#34;&gt;#&lt;/a&gt; 顶点着色器&lt;/h3&gt;
&lt;p&gt;从之前博客中的顶点着色器，增加一些修改：&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;attribute vec2 a_TexCoordinate;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;varying vec2 v_TexCoordinate;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;//将纹理坐标信息传递给片段着色器&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;v_TexCoordinate = a_TexCoordinate;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br /&gt;
 在顶点着色器中我们添加了一个新的 attribute 类型 2 维向量来携带纹理的坐标信息作为输入数据。这会是基于每个顶点的，就像是位置，颜色，法线数据一样。我们还添加了一个新的 varying 型的变量来将数据传递进片段着色器中，通过三角形表面线性插入。&lt;/p&gt;
&lt;h3 id=&#34;片段着色器&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#片段着色器&#34;&gt;#&lt;/a&gt; 片段着色器&lt;/h3&gt;
&lt;p&gt;&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;uniform sampler2D u_Texture;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;varing vec2 v_TexCoordinate;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;..&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;diffuse = diffuse * (1.0/(1.0+(0.1.*distance)));&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;diffuse = diffuse + 0.3;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;gl_FragColor = (c_Color*diffuse*texture2D(u_Texture,v_TexCoordinate));&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;我们添加了一个新的 uniform 类型 sampler2D 代表了实际的纹理数据 ()，v_TexCoordinate 从顶点着色器中获取到了纹理坐标数据，之后我们调用 texture2D (texture,textureCoordinate) 来读出纹理在当前坐标处的值。获取到了这个值后将它与其它项相乘就得到了最后的输出颜色。这种方式添加的纹理会有时在整个环境中较暗，所以可以将环境光上调一些来减少光的衰减。&lt;/p&gt;
&lt;h3 id=&#34;从一个图像中加载纹理&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#从一个图像中加载纹理&#34;&gt;#&lt;/a&gt; 从一个图像中加载纹理&lt;/h3&gt;
&lt;p&gt;&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;25&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;public static int loadTexture(Bitmap bitmap)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;       int[] textureHandle = new int[1];&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;       //由OpenGL ES生成一个纹理句柄并存放到textureHandle中&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;       GLES20.glGenTextures(1,textureHandle,0);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;       if(textureHandle[0]!=0)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;           //将纹理绑定到OpenGL上&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;           GLES20.glBindTexture(GLES20.GL_TEXTURE_2D,textureHandle[0]);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;           // Set filtering&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;           GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_NEAREST);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;           GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_NEAREST);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;           GLUtils.texImage2D(GLES20.GL_TEXTURE_2D, 0, bitmap, 0);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;           // Recycle the bitmap, since its data has been loaded into OpenGL.&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;           bitmap.recycle();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;       &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;       if (textureHandle[0] == 0)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;       &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;           throw new RuntimeException(&amp;quot;Error loading texture.&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;       &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;       return textureHandle[0];&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br /&gt;
 传入一个 Bitmap 对象并将其加载到 OpenGL 中&lt;/p&gt;
&lt;h3 id=&#34;定义纹理坐标&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#定义纹理坐标&#34;&gt;#&lt;/a&gt; 定义纹理坐标&lt;/h3&gt;
&lt;p&gt;我们知道纹理坐标系左下是（0，0），而右上是（1，1），而我们的之前定义一个矩形是&lt;/p&gt;
&lt;p&gt;-1,1，&lt;/p&gt;
&lt;p&gt;-1,-1,&lt;/p&gt;
&lt;p&gt;1,1,&lt;/p&gt;
&lt;p&gt;-1,-1,&lt;/p&gt;
&lt;p&gt;1,-1,&lt;/p&gt;
&lt;p&gt;1,1&lt;/p&gt;
&lt;p&gt;这样的顺序定义的，&lt;br /&gt;
我们的纹理坐标应该是怎么样的呢：&lt;/p&gt;
&lt;p&gt;0f,0f,&lt;/p&gt;
&lt;p&gt;0f,1f,&lt;/p&gt;
&lt;p&gt;1f,0f,&lt;/p&gt;
&lt;p&gt;0f,1f,&lt;/p&gt;
&lt;p&gt;1f,1f,&lt;/p&gt;
&lt;p&gt;1f,0f.&lt;/p&gt;
&lt;p&gt;这个坐标的对应顺序可以自己在纸上画一下来增强理解.&lt;br /&gt;
(我个人理解和这个文章的作者不一样，在 Android 上，纹理坐标系好像是和 Android 的 2d 坐标系相同，Android 的 2D 坐标系是 y 轴向下为正，x 轴向右为正，坐标原点为左上，以左上角为 (0,0)，所以将纹理映射到 OpenGL 坐标系中就是上面这样)&lt;/p&gt;
&lt;h3 id=&#34;使用纹理&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#使用纹理&#34;&gt;#&lt;/a&gt; 使用纹理&lt;/h3&gt;
&lt;p&gt;在 GLES20.glUseProgram 之后添加下面的代码：&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;//纹理坐标句柄&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;mTextureHandle = GLES20.glGetAttribLocation(Program,&amp;quot;a_TexCoordinate&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;//纹理采样器句柄&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;mTextureCoordHandle = GLES20.glGetUniformLocation(Program,&amp;quot;u_Texture&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;//将纹理坐标传递进着色器程序&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;mTriangleTexture.position(0);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;GLES20.glVertexAttribPointer(mTextureHandle,2 ,GLES20.GL_FLOAT,false,0,mTriangleTexture);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;GLES20.glEnableVertexAttribArray(mTextureHandle);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;//激活第一个纹理单元&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;GLES20.glActiveTexture(GLES20.GL_TEXTURE0);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;//绑定纹理到指定的纹理通道，GL_TEXTURE_2D在着色器中就会使用simpler2D。&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;GLES20.glBindTexture(GLES20.GL_TEXTURE_2D,mTextureDataHandle);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;//只使用一个纹理的话给Simpler2D传0就可以&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;GLES20.glUniform1i(mTextureCoordHandle,0);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
</content>
        <category term="图像处理" />
        <category term="OpenGL ES" />
        <category term="OpenGL ES2.0" />
        <updated>2017-07-12T02:49:46.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2017/07/10/OpenGL-ES2-0%E4%B8%AD%E7%9A%84%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2/</id>
        <title>OpenGL ES2.0中的坐标变换</title>
        <link rel="alternate" href="http://example.com/2017/07/10/OpenGL-ES2-0%E4%B8%AD%E7%9A%84%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2/"/>
        <content type="html">&lt;h1 id=&#34;opengl-es中的坐标变换&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#opengl-es中的坐标变换&#34;&gt;#&lt;/a&gt; OpenGL ES 中的坐标变换&lt;/h1&gt;
&lt;h2 id=&#34;opengl-es中的坐标系&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#opengl-es中的坐标系&#34;&gt;#&lt;/a&gt; OpenGL ES 中的坐标系&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;世界坐标系&lt;/li&gt;
&lt;li&gt;纹理坐标系&lt;/li&gt;
&lt;li&gt;物体坐标系&lt;/li&gt;
&lt;li&gt;眼坐标系或相机坐标系&lt;/li&gt;
&lt;li&gt;裁剪坐标系&lt;/li&gt;
&lt;li&gt;屏幕坐标系&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;世界坐标系&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#世界坐标系&#34;&gt;#&lt;/a&gt; 世界坐标系&lt;/h3&gt;
&lt;p&gt;世界坐标系是 OpenGL 中描绘三位空间的坐标系&lt;/p&gt;
&lt;h3 id=&#34;纹理坐标系&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#纹理坐标系&#34;&gt;#&lt;/a&gt; 纹理坐标系&lt;/h3&gt;
&lt;p&gt;一种假象的坐标系&lt;br /&gt;
可以叫 UV 坐标系&lt;br /&gt;
一个纹理的纹理坐标左上角为（0，0），右下为（1，1），坐标用浮点数表示&lt;br /&gt;
 [外链图片转存中...(img-RtLrvTin-1648314227884)]&lt;/p&gt;
&lt;h3 id=&#34;物体坐标系&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#物体坐标系&#34;&gt;#&lt;/a&gt; 物体坐标系&lt;/h3&gt;
&lt;p&gt;相对于单个物体的坐标系&lt;/p&gt;
&lt;h3 id=&#34;相机坐标系&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#相机坐标系&#34;&gt;#&lt;/a&gt; 相机坐标系&lt;/h3&gt;
&lt;p&gt;相机坐标系是以相机为原地，相机观察方向 z 轴向内为正方向的坐标系&lt;/p&gt;
&lt;h3 id=&#34;裁剪坐标系&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#裁剪坐标系&#34;&gt;#&lt;/a&gt; 裁剪坐标系&lt;/h3&gt;
&lt;p&gt;将相机坐标系乘以 ProjectionMatrix 就可以得到裁剪坐标系&lt;/p&gt;
&lt;h3 id=&#34;屏幕坐标系&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#屏幕坐标系&#34;&gt;#&lt;/a&gt; 屏幕坐标系&lt;/h3&gt;
&lt;p&gt;最终显示到屏幕上的坐标系&lt;/p&gt;
&lt;h3 id=&#34;坐标变换&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#坐标变换&#34;&gt;#&lt;/a&gt; 坐标变换&lt;/h3&gt;
&lt;p&gt;&lt;img data-src=&#34;https://img-blog.csdnimg.cn/img_convert/4b5aa0e7049bdab4fcd7db83190de3f0.png&#34; alt=&#34;OpenGL中的坐标变换&#34; /&gt;&lt;/p&gt;
&lt;h3 id=&#34;在android进行opengles的坐标矩阵变换&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#在android进行opengles的坐标矩阵变换&#34;&gt;#&lt;/a&gt; 在 Android 进行 OpenGLES 的坐标矩阵变换&lt;/h3&gt;
&lt;p&gt;&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;24&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;float ModelMatrix = new float[16];//一个4*4矩阵&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;float ViewMatrix = new float[16];&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;float ProjectionMatrix = new float[16];&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;float MVPMatrix = new float[16];&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;float eyeX = 0f;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;float eyeY = 0f;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;float eyeZ = -5f;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;float lookAtX = 0f;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;float lookAtY  = 0f;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;float lookAtZ = 0f;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;float upX = 0f;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;float upY = 1f;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;float upZ = 0f; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;//设置ViewMatrix矩阵，up为垂直于视线的向量&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;Matrix.setLookAtM(ViewMatrix,0，eyeX,eyeY,eyeZ,lookAtX,lookAtY,lookAtZ,upX,upY,upZ);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;//矩阵乘以矩阵&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;Matrix.multiplyMM();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;//矩阵乘以向量&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;Matrix.multiplyMV();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
</content>
        <category term="图像处理" />
        <category term="OpenGL ES" />
        <category term="OpenGL ES2.0" />
        <updated>2017-07-10T13:20:47.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2017/07/10/OpenGL-ES2-0%E4%B8%AD%E7%9A%84%E5%85%89%E7%85%A7/</id>
        <title>OpenGL ES2.0中的光照</title>
        <link rel="alternate" href="http://example.com/2017/07/10/OpenGL-ES2-0%E4%B8%AD%E7%9A%84%E5%85%89%E7%85%A7/"/>
        <content type="html">&lt;h1 id=&#34;opengles20中的光照&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#opengles20中的光照&#34;&gt;#&lt;/a&gt; OpenGLES2.0 中的光照&lt;/h1&gt;
&lt;p&gt;翻译自&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL3d3dy5sZWFybm9wZW5nbGVzLmNvbS9hbmRyb2lkLWxlc3Nvbi10d28tYW1iaWVudC1hbmQtZGlmZnVzZS1saWdodGluZy8=&#34;&gt; Android 课程二：环境光和漫反射光&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&#34;1什么是光&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#1什么是光&#34;&gt;#&lt;/a&gt; 1. 什么是光？&lt;/h2&gt;
&lt;p&gt;世界没有光就会什么也看不到，我们将无法感知这个世界活着物体。&lt;/p&gt;
&lt;p&gt;在真实的世界里，光是由无数的光子聚合在一起形成的，它从一个光源出发，经过无数时间，最后传递到了我们的眼睛里&lt;/p&gt;
&lt;p&gt;我们应该如何用计算机图像模拟光呢，现在有 2 种热门技术可以实现：光线跟踪和栅格化。光线跟踪通过数学计算跟踪真实的光线，能给出十分准确和真实的结果，但是不足之处是模拟所有的光线十分消耗计算资源，并且实时渲染速度很慢。由于这个限制，大多数的实时计算机图像使用的是栅格化技术，通过接近结果模拟光线。&lt;/p&gt;
&lt;h2 id=&#34;2光线的分类&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#2光线的分类&#34;&gt;#&lt;/a&gt; 2. 光线的分类&lt;/h2&gt;
&lt;p&gt;我们可以抽象出光工作的方式形成三种基本的光线类型&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;环境光&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;环境光是一种基础的光线，它遍布整个场景，它没有表现出来自任何其他的光源，因为它在到达你之前经过了无数的反射。这种光能阴天的户外，或是许多不同光源累积影响的室内。没有分别计算所有独立的光，我们可以为对象或场景设置一个基本的光照等级。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;漫反射光&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这种光在到达教你的眼睛里经过了物体之间反射。物体的光照等级随它与光线的角度不同而变化。直面它的时候更加明亮。同样我们感知物体时无论我们相对物体的位置在哪里，亮点都是相同的。这种现象也叫兰伯特余弦定律（Lambert&#39;s cosine law），漫反射和兰伯特反射在生活中是很常见的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;高光&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;和漫反射不同，高光随我们和物体的位置不同而不同，它让物体发亮和更加光滑&lt;/p&gt;
&lt;h2 id=&#34;2模拟光&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#2模拟光&#34;&gt;#&lt;/a&gt; 2. 模拟光&lt;/h2&gt;
&lt;p&gt;与在 3D 场景中的光有 3 种一样，光源也有 3 种：直接光源、Point lighting、Spot lighting。&lt;/p&gt;
&lt;h3 id=&#34;1数学&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#1数学&#34;&gt;#&lt;/a&gt; 1. 数学&lt;/h3&gt;
&lt;p&gt;学习来自一个点光源的环境光和漫反射光&lt;/p&gt;
&lt;h4 id=&#34;环境光&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#环境光&#34;&gt;#&lt;/a&gt; 环境光&lt;/h4&gt;
&lt;p&gt;环境光其实是漫反射光的一种，但是它也能被看作是充满整个场景的低级光。这样想的话，它会很容易计算&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;final color = material color * ambient light color&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br /&gt;
 例如，有个物体是红色的，我们的环境光是灰白的。让我们假定将颜色存储为有 3 个颜色的数组红、绿、蓝，使用 RGB 颜色模型：&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;final color = &amp;#123; 1 , 0 , 0 &amp;#125; * &amp;#123; 0.1 , 0.1 , 0.1 &amp;#125; = &amp;#123; 0.1 , 0.0 , 0.0 &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;最终物体的颜色会是淡红色。基础的场景光就是这样的，除非你想要更加高级的视觉技术&lt;/p&gt;
&lt;h4 id=&#34;漫反射光-点光源&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#漫反射光-点光源&#34;&gt;#&lt;/a&gt; 漫反射光 - 点光源&lt;/h4&gt;
&lt;p&gt;对漫反射光，我们需要增加衰减和光的位置。光的位置会用来计算光和表面的角度，它会影响表面的光照的整个等级。它还用来计算光和表面的距离，并决定了那个点的光照强度。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;步骤一： 计算兰伯特因子&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;我们需要的第一个主要的计算是计算出表明和光的角度。直面光线的表层会处于光照的最大强度。计算出这个属性的合适的方式是使用兰伯特余弦定理。如果我们有 2 个向量，一个是从光线到表面的一个点，第二个是曲面法线，我们可以计算出余弦值：先将各个向量归一化，因此有它们的长度为 1，然后计算出 2 个向量的点积。这个操作能通过 OpenGL ES 的两个着色器轻松完成。&lt;/p&gt;
&lt;p&gt;我们声明 lambert 因子，它的范围是 0 到 1&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;light vector = light position - obejct position&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;cosine = dot product(object normal,normalize(light vector))&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;lambert factor = max(cosine,0)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br /&gt;
 首先我们通过对象位置减去光线位置计算出光线的向量，然后我们获取物体的法线和光线向量的点积，就得到了这个余弦了。归一化光线向量的意思就是改变它的长度为 1。因为点积德范围是 - 1 到 1，我们把它固定到（0，1）。&lt;/p&gt;
&lt;p&gt;这是一个例子：有个光滑的平面，表面的法线笔直的指向天。光线的位置为「0，10，-10」，或是向上 10 个单位，向前 10 个单位，我们要计算出原地的光&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;light vector = &amp;#123; 0, 10, -10&amp;#125; - &amp;#123;0, 0, 0&amp;#125; = &amp;#123;0, 10, -10&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;obejct normal = &amp;#123;0, 1, 0&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br /&gt;
 用平白的语言来说，如果我们沿着光线向量出发移动，到达光线的位置。要归一化这个向量，我们让向量的每一个标量处以向量的长度：&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;light vector length = square root( 0*0 + 10*10 + -10*-10) = square root(200) = 14.14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;normalized light vector = &amp;#123;0/14.14, 10/14.14, -10/14.14&amp;#125; = &amp;#123;0, 0.707, -0.707&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br /&gt;
 然后我们计算点积&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;dot product(&amp;#123;0,1,0&amp;#125;,&amp;#123;0,0.707, -0.707&amp;#125;) = 0*0 + 1*0.707 + 0*-0.707 = 0.707&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;lambert factor = max(0.707,0) = 0.707&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;OpenGL ES 2 的着色器语言已经内置了一些这种函数，所以我们不需要手动做所有的数学，但是这对我们的理解仍然有帮助。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;步骤二：计算衰减因子&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;接着，我们需要计算衰减，真实的点光源的光线衰减遵从&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL2JhaWtlLmJhaWR1LmNvbS9saW5rP3VybD1fa2RXcG5oNXJJVnZ0Y0tlQU1wZGRsWkdKUDJlNjVCM2V2cGQ4QS1mVFA0UFpqTG9RN09PdHpqQXJURHpWdmVMUEt2UllvaUxnQjJZSXdyTmswVVp3V3FQbHVsdnF4VjdKcjF0dXltZ3Y0eDhKS21hSVJpbGhKc0dxN1JuMmRFOHRHOHY3bFFtTnQ1aGVFRXExdDhrRUs=&#34;&gt;平方反比定律&lt;/span&gt;，它可以表述为：&lt;br /&gt;
 &lt;code&gt;luminosity = 1 / (distance* distance)&lt;/code&gt; &lt;br /&gt;
 回到我们的例子，我们知道了一个距离为 14.14，所以最后我们的亮度看起来是：&lt;br /&gt;
 &lt;code&gt;luminosity = 1/ (14.14*14.14) = 0.005&lt;/code&gt; &lt;br /&gt;
 你可以看到，平方反比定律在距离上会导致剧烈的衰减。这就是光在真实世界中从点光源出发是怎么回事，但是我们的图像显示有限制范围，因此抑制衰减因子，我们能得到更加真实的光照而不会使物体看起来太暗了。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;步骤三：计算最后的颜色&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;现在我们同时有了余弦和衰减因子，我们能计算出最终的光照等级：&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;final color = meterial color * (light color * lambert factor * luminosity)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;回到之前一个例子，我们有红色的材料和全白的光源，最终的计算：&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;final color = &amp;#123;1, 0, 0&amp;#125; *(&amp;#123;1,1,1&amp;#125;*0.707*0.005) &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;= &amp;#123;1,0,0&amp;#125;*&amp;#123;0.0035,0.0035,0.0035&amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;= &amp;#123;0.0035,0,0&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;简单的总结一下，对漫反射光我们需要使用表面和光线的角度，还有表面和光线的距离来最终计算出整个漫反射照明等级。下面是步骤：&lt;/p&gt;
&lt;p&gt;&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;//one&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;light vector = light position - object position&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;cosine = dot product(object normal,normalize(light vector))&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;lambert factor = max(cosine,0)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;//two&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;luminosity = 1/(distance*distance)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;//three&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;final color = material color * (light color*lambert factor * luminosity)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&#34;顶点着色器&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#顶点着色器&#34;&gt;#&lt;/a&gt; 顶点着色器&lt;/h4&gt;
&lt;p&gt;&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;31&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;final String vertexShader =&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;quot;uniform mat4 u_MVPMatrix;      \n&amp;quot;     // 一个表示进行了Model变换、View变换、投影变换的矩阵&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  + &amp;quot;uniform mat4 u_MVMatrix;       \n&amp;quot;     // 一个表示进行了Model变换和View变换的矩阵&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  + &amp;quot;uniform vec3 u_LightPos;       \n&amp;quot;     // 在眼坐标系中光的位置&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  + &amp;quot;attribute vec4 a_Position;     \n&amp;quot;     // 传入的顶点位置信息&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  + &amp;quot;attribute vec4 a_Color;        \n&amp;quot;     // 传人的每个顶点的颜色信息&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  + &amp;quot;attribute vec3 a_Normal;       \n&amp;quot;     // 每个顶点的法线信息&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  + &amp;quot;varying vec4 v_Color;          \n&amp;quot;     // 颜色信息，这个变量会传递进片段着色器中&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  + &amp;quot;void main()                    \n&amp;quot;     &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  + &amp;quot;&amp;#123;                              \n&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;// 将顶点转化为眼坐标系&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  + &amp;quot;   vec3 modelViewVertex = vec3(u_MVMatrix * a_Position);              \n&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;// 将法线方向转移进眼坐标系&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  + &amp;quot;   vec3 modelViewNormal = vec3(u_MVMatrix * vec4(a_Normal, 0.0));     \n&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;// 计算出顶点和光线的距离  &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  + &amp;quot;   float distance = length(u_LightPos - modelViewVertex);             \n&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;// 获取从光线处到顶点的光线向量&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  + &amp;quot;   vec3 lightVector = normalize(u_LightPos - modelViewVertex);        \n&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;// 计算lambert factor，也就是计算光线向量和顶点法线的点积. 如果法线向量和光线向量指向同一个方向，则会得出最大的光照强度.&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  + &amp;quot;   float lambert = max(dot(modelViewNormal, lightVector), 0.1);       \n&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;// 光线随距离的衰减&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  + &amp;quot;   float diffuse = lambert * (1.0 / (1.0 + (0.25 * distance * distance)));  \n&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;// 将颜色乘以衰减度， It will be interpolated across the triangle.&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  + &amp;quot;   v_Color = a_Color * diffuse;                                       \n&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;// gl_Position 存储最终的位置.&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;// 将这个向量乘以变换矩阵得到在归一屏幕坐标系中的点&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  + &amp;quot;   gl_Position = u_MVPMatrix * a_Position;                            \n&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  + &amp;quot;&amp;#125;                                                                     \n&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&#34;片段着色器&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#片段着色器&#34;&gt;#&lt;/a&gt; 片段着色器&lt;/h4&gt;
&lt;p&gt;&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;final String fragmentShader =&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &amp;quot;precision mediump float;       \n&amp;quot;     // Set the default precision to medium. We don&amp;#x27;t need as high of a&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                                          // precision in the fragment shader.&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;+ &amp;quot;varying vec4 v_Color;          \n&amp;quot;     // This is the color from the vertex shader interpolated across the&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                                          // triangle per fragment.&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;+ &amp;quot;void main()                    \n&amp;quot;     // The entry point for our fragment shader.&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;+ &amp;quot;&amp;#123;                              \n&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;+ &amp;quot;   gl_FragColor = v_Color;     \n&amp;quot;     // Pass the color directly through the pipeline.&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;+ &amp;quot;&amp;#125;                              \n&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&#34;光源的顶点-片段着色器&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#光源的顶点-片段着色器&#34;&gt;#&lt;/a&gt; 光源的顶点、片段着色器&lt;/h4&gt;
&lt;p&gt;&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;// Define a simple shader program for our point.&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;final String pointVertexShader =&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;quot;uniform mat4 u_MVPMatrix;      \n&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  + &amp;quot;attribute vec4 a_Position;     \n&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  + &amp;quot;void main()                    \n&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  + &amp;quot;&amp;#123;                              \n&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  + &amp;quot;   gl_Position = u_MVPMatrix   \n&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  + &amp;quot;               * a_Position;   \n&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  + &amp;quot;   gl_PointSize = 5.0;         \n&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  + &amp;quot;&amp;#125;                              \n&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;final String pointFragmentShader =&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;quot;precision mediump float;       \n&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  + &amp;quot;void main()                    \n&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  + &amp;quot;&amp;#123;                              \n&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  + &amp;quot;   gl_FragColor = vec4(1.0,    \n&amp;quot; //直接指定片段颜色为白色&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  + &amp;quot;   1.0, 1.0, 1.0);             \n&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  + &amp;quot;&amp;#125;                              \n&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;有一个新的属性叫 &lt;code&gt;gl_PointSize&lt;/code&gt;  是点在空间中的大小为多少个像素。&lt;/p&gt;
</content>
        <category term="图像处理" />
        <category term="OpenGL ES" />
        <category term="OpenGL ES2.0" />
        <updated>2017-07-10T12:53:21.000Z</updated>
    </entry>
</feed>
