{
    "version": "https://jsonfeed.org/version/1",
    "title": "花咲く • All posts by \"opengl es\" tag",
    "description": "编程笔记 & 学渣的自救",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2017/07/12/OpenGL-ES2-0%E4%B8%AD%E7%9A%84%E7%BA%B9%E7%90%86/",
            "url": "http://example.com/2017/07/12/OpenGL-ES2-0%E4%B8%AD%E7%9A%84%E7%BA%B9%E7%90%86/",
            "title": "OpenGL ES2.0中的纹理",
            "date_published": "2017-07-12T02:49:46.000Z",
            "content_html": "<h1 id=\"opengl-中的texture纹理\"><a class=\"anchor\" href=\"#opengl-中的texture纹理\">#</a> OpenGL 中的 Texture（纹理）</h1>\n<p>翻译自<span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5sZWFybm9wZW5nbGVzLmNvbS9hbmRyb2lkLWxlc3Nvbi1mb3VyLWludHJvZHVjaW5nLWJhc2ljLXRleHR1cmluZy8=\"> Android 课程 3：基础纹理</span> 英语好的小伙伴可以直接去这个网站学习 OpenGL ES2</p>\n<h2 id=\"纹理介绍\"><a class=\"anchor\" href=\"#纹理介绍\">#</a> 纹理介绍</h2>\n<p>纹理映射技术是构建一个真实 3D 世界最重要的方式。没有纹理映射的话，所以的东西都是光滑的渐变，看起来像人造的，像是 90 年代的控制台游戏</p>\n<p>首先大量使用了纹理技术的游戏，比如 Doom 和 Duke Nukem 3D，通过添加的视觉影响能极大的增强了游戏的真实性。</p>\n<h2 id=\"纹理坐标系\"><a class=\"anchor\" href=\"#纹理坐标系\">#</a> 纹理坐标系</h2>\n<p>在 OpenGL 中，纹理坐标系使用（s，t）来代替（x，y）坐标，代表纹理上的点，最终映射到几何形上。另外需要注意的是纹理坐标系和其他的 OpenGL 坐标系一样，t（y）轴指向上，因此位置越高值越大。</p>\n<p>[外链图片转存失败，源站可能有防盗链机制，建议将图片保存下来直接上传 (img-AiDSpFC1-1648314308409)(<span class=\"exturl\" data-url=\"aHR0cDovL2ltZzQuaW1ndG4uYmRpbWcuY29tL2l0L3U9MjIyNjEzNjg0MywxNjkzMDA3ODk1JmFtcDtmbT0yNiZhbXA7Z3A9MC5qcGc=\">http://img4.imgtn.bdimg.com/it/u=2226136843,1693007895&amp;fm=26&amp;gp=0.jpg</span>)]</p>\n<h2 id=\"纹理映射\"><a class=\"anchor\" href=\"#纹理映射\">#</a> 纹理映射</h2>\n<p>在这课中注意看 2D 纹理 (GL_TEXTURE_2D)。OpenGL ES 也提供了其他的纹理模型让你做不同和专业的效果。</p>\n<h3 id=\"顶点着色器\"><a class=\"anchor\" href=\"#顶点着色器\">#</a> 顶点着色器</h3>\n<p>从之前博客中的顶点着色器，增加一些修改：</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">attribute vec2 a_TexCoordinate;</span><br><span class=\"line\">...</span><br><span class=\"line\">varying vec2 v_TexCoordinate;</span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">//将纹理坐标信息传递给片段着色器</span><br><span class=\"line\">v_TexCoordinate = a_TexCoordinate;</span><br></pre></td></tr></table></figure><br />\n 在顶点着色器中我们添加了一个新的 attribute 类型 2 维向量来携带纹理的坐标信息作为输入数据。这会是基于每个顶点的，就像是位置，颜色，法线数据一样。我们还添加了一个新的 varying 型的变量来将数据传递进片段着色器中，通过三角形表面线性插入。</p>\n<h3 id=\"片段着色器\"><a class=\"anchor\" href=\"#片段着色器\">#</a> 片段着色器</h3>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uniform sampler2D u_Texture;</span><br><span class=\"line\">...</span><br><span class=\"line\">\u0010varing vec2 v_TexCoordinate;</span><br><span class=\"line\">..</span><br><span class=\"line\">diffuse = diffuse * (1.0/(1.0+(0.1.*distance)));</span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">diffuse = diffuse + 0.3;</span><br><span class=\"line\"></span><br><span class=\"line\">gl_FragColor = (c_Color*diffuse*texture2D(u_Texture,v_TexCoordinate));</span><br></pre></td></tr></table></figure></p>\n<p>我们添加了一个新的 uniform 类型 sampler2D 代表了实际的纹理数据 ()，v_TexCoordinate 从顶点着色器中获取到了纹理坐标数据，之后我们调用 texture2D (texture,textureCoordinate) 来读出纹理在当前坐标处的值。获取到了这个值后将它与其它项相乘就得到了最后的输出颜色。这种方式添加的纹理会有时在整个环境中较暗，所以可以将环境光上调一些来减少光的衰减。</p>\n<h3 id=\"从一个图像中加载纹理\"><a class=\"anchor\" href=\"#从一个图像中加载纹理\">#</a> 从一个图像中加载纹理</h3>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static int loadTexture(Bitmap bitmap)&#123;</span><br><span class=\"line\">       int[] textureHandle = new int[1];</span><br><span class=\"line\">       //由OpenGL ES生成一个纹理句柄并存放到textureHandle中</span><br><span class=\"line\">       GLES20.glGenTextures(1,textureHandle,0);</span><br><span class=\"line\">       if(textureHandle[0]!=0)&#123;</span><br><span class=\"line\">           //将纹理绑定到OpenGL上</span><br><span class=\"line\">           GLES20.glBindTexture(GLES20.GL_TEXTURE_2D,textureHandle[0]);</span><br><span class=\"line\">           // Set filtering</span><br><span class=\"line\">           GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_NEAREST);</span><br><span class=\"line\">           GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_NEAREST);</span><br><span class=\"line\"></span><br><span class=\"line\">           GLUtils.texImage2D(GLES20.GL_TEXTURE_2D, 0, bitmap, 0);</span><br><span class=\"line\"></span><br><span class=\"line\">           // Recycle the bitmap, since its data has been loaded into OpenGL.</span><br><span class=\"line\">           bitmap.recycle();</span><br><span class=\"line\"></span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       if (textureHandle[0] == 0)</span><br><span class=\"line\">       &#123;</span><br><span class=\"line\">           throw new RuntimeException(&quot;Error loading texture.&quot;);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       return textureHandle[0];</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure><br />\n 传入一个 Bitmap 对象并将其加载到 OpenGL 中</p>\n<h3 id=\"定义纹理坐标\"><a class=\"anchor\" href=\"#定义纹理坐标\">#</a> 定义纹理坐标</h3>\n<p>我们知道纹理坐标系左下是（0，0），而右上是（1，1），而我们的之前定义一个矩形是</p>\n<p>-1,1，</p>\n<p>-1,-1,</p>\n<p>1,1,</p>\n<p>-1,-1,</p>\n<p>1,-1,</p>\n<p>1,1</p>\n<p>这样的顺序定义的，<br />\n我们的纹理坐标应该是怎么样的呢：</p>\n<p>0f,0f,</p>\n<p>0f,1f,</p>\n<p>1f,0f,</p>\n<p>0f,1f,</p>\n<p>1f,1f,</p>\n<p>1f,0f.</p>\n<p>这个坐标的对应顺序可以自己在纸上画一下来增强理解.<br />\n(我个人理解和这个文章的作者不一样，在 Android 上，纹理坐标系好像是和 Android 的 2d 坐标系相同，Android 的 2D 坐标系是 y 轴向下为正，x 轴向右为正，坐标原点为左上，以左上角为 (0,0)，所以将纹理映射到 OpenGL 坐标系中就是上面这样)</p>\n<h3 id=\"使用纹理\"><a class=\"anchor\" href=\"#使用纹理\">#</a> 使用纹理</h3>\n<p>在 GLES20.glUseProgram 之后添加下面的代码：</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//纹理坐标句柄</span><br><span class=\"line\">mTextureHandle = GLES20.glGetAttribLocation(Program,&quot;a_TexCoordinate&quot;);</span><br><span class=\"line\">//纹理采样器句柄</span><br><span class=\"line\">mTextureCoordHandle = GLES20.glGetUniformLocation(Program,&quot;u_Texture&quot;);</span><br><span class=\"line\">        </span><br><span class=\"line\">//将纹理坐标传递进着色器程序</span><br><span class=\"line\">mTriangleTexture.position(0);</span><br><span class=\"line\">GLES20.glVertexAttribPointer(mTextureHandle,2 ,GLES20.GL_FLOAT,false,0,mTriangleTexture);</span><br><span class=\"line\">GLES20.glEnableVertexAttribArray(mTextureHandle);</span><br><span class=\"line\"></span><br><span class=\"line\">//激活第一个纹理单元</span><br><span class=\"line\">GLES20.glActiveTexture(GLES20.GL_TEXTURE0);</span><br><span class=\"line\">//绑定纹理到指定的纹理通道，GL_TEXTURE_2D在着色器中就会使用simpler2D。</span><br><span class=\"line\">GLES20.glBindTexture(GLES20.GL_TEXTURE_2D,mTextureDataHandle);</span><br><span class=\"line\">//只使用一个纹理的话给Simpler2D传0就可以</span><br><span class=\"line\">GLES20.glUniform1i(mTextureCoordHandle,0);</span><br></pre></td></tr></table></figure></p>\n",
            "tags": [
                "图像处理",
                "OpenGL ES",
                "OpenGL ES2.0"
            ]
        },
        {
            "id": "http://example.com/2017/07/10/OpenGL-ES2-0%E4%B8%AD%E7%9A%84%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2/",
            "url": "http://example.com/2017/07/10/OpenGL-ES2-0%E4%B8%AD%E7%9A%84%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2/",
            "title": "OpenGL ES2.0中的坐标变换",
            "date_published": "2017-07-10T13:20:47.000Z",
            "content_html": "<h1 id=\"opengl-es中的坐标变换\"><a class=\"anchor\" href=\"#opengl-es中的坐标变换\">#</a> OpenGL ES 中的坐标变换</h1>\n<h2 id=\"opengl-es中的坐标系\"><a class=\"anchor\" href=\"#opengl-es中的坐标系\">#</a> OpenGL ES 中的坐标系</h2>\n<ul>\n<li>世界坐标系</li>\n<li>纹理坐标系</li>\n<li>物体坐标系</li>\n<li>眼坐标系或相机坐标系</li>\n<li>裁剪坐标系</li>\n<li>屏幕坐标系</li>\n</ul>\n<h3 id=\"世界坐标系\"><a class=\"anchor\" href=\"#世界坐标系\">#</a> 世界坐标系</h3>\n<p>世界坐标系是 OpenGL 中描绘三位空间的坐标系</p>\n<h3 id=\"纹理坐标系\"><a class=\"anchor\" href=\"#纹理坐标系\">#</a> 纹理坐标系</h3>\n<p>一种假象的坐标系<br />\n可以叫 UV 坐标系<br />\n一个纹理的纹理坐标左上角为（0，0），右下为（1，1），坐标用浮点数表示<br />\n [外链图片转存中...(img-RtLrvTin-1648314227884)]</p>\n<h3 id=\"物体坐标系\"><a class=\"anchor\" href=\"#物体坐标系\">#</a> 物体坐标系</h3>\n<p>相对于单个物体的坐标系</p>\n<h3 id=\"相机坐标系\"><a class=\"anchor\" href=\"#相机坐标系\">#</a> 相机坐标系</h3>\n<p>相机坐标系是以相机为原地，相机观察方向 z 轴向内为正方向的坐标系</p>\n<h3 id=\"裁剪坐标系\"><a class=\"anchor\" href=\"#裁剪坐标系\">#</a> 裁剪坐标系</h3>\n<p>将相机坐标系乘以 ProjectionMatrix 就可以得到裁剪坐标系</p>\n<h3 id=\"屏幕坐标系\"><a class=\"anchor\" href=\"#屏幕坐标系\">#</a> 屏幕坐标系</h3>\n<p>最终显示到屏幕上的坐标系</p>\n<h3 id=\"坐标变换\"><a class=\"anchor\" href=\"#坐标变换\">#</a> 坐标变换</h3>\n<p><img data-src=\"https://img-blog.csdnimg.cn/img_convert/4b5aa0e7049bdab4fcd7db83190de3f0.png\" alt=\"OpenGL中的坐标变换\" /></p>\n<h3 id=\"在android进行opengles的坐标矩阵变换\"><a class=\"anchor\" href=\"#在android进行opengles的坐标矩阵变换\">#</a> 在 Android 进行 OpenGLES 的坐标矩阵变换</h3>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">float ModelMatrix = new float[16];//一个4*4矩阵</span><br><span class=\"line\">float ViewMatrix = new float[16];</span><br><span class=\"line\">float ProjectionMatrix = new float[16];</span><br><span class=\"line\">float MVPMatrix = new float[16];</span><br><span class=\"line\"></span><br><span class=\"line\">float eyeX = 0f;</span><br><span class=\"line\">float eyeY = 0f;</span><br><span class=\"line\">float eyeZ = -5f;</span><br><span class=\"line\"></span><br><span class=\"line\">float lookAtX = 0f;</span><br><span class=\"line\">float lookAtY  = 0f;</span><br><span class=\"line\">float lookAtZ = 0f;</span><br><span class=\"line\"></span><br><span class=\"line\">float upX = 0f;</span><br><span class=\"line\">float upY = 1f;</span><br><span class=\"line\">float upZ = 0f; </span><br><span class=\"line\">//设置ViewMatrix矩阵，up为垂直于视线的向量</span><br><span class=\"line\">Matrix.setLookAtM(ViewMatrix,0，eyeX,eyeY,eyeZ,lookAtX,lookAtY,lookAtZ,upX,upY,upZ);</span><br><span class=\"line\"></span><br><span class=\"line\">//矩阵乘以矩阵</span><br><span class=\"line\">Matrix.multiplyMM();</span><br><span class=\"line\">//矩阵乘以向量</span><br><span class=\"line\">Matrix.multiplyMV();</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n",
            "tags": [
                "图像处理",
                "OpenGL ES",
                "OpenGL ES2.0"
            ]
        },
        {
            "id": "http://example.com/2017/07/10/OpenGL-ES2-0%E4%B8%AD%E7%9A%84%E5%85%89%E7%85%A7/",
            "url": "http://example.com/2017/07/10/OpenGL-ES2-0%E4%B8%AD%E7%9A%84%E5%85%89%E7%85%A7/",
            "title": "OpenGL ES2.0中的光照",
            "date_published": "2017-07-10T12:53:21.000Z",
            "content_html": "<h1 id=\"opengles20中的光照\"><a class=\"anchor\" href=\"#opengles20中的光照\">#</a> OpenGLES2.0 中的光照</h1>\n<p>翻译自<span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5sZWFybm9wZW5nbGVzLmNvbS9hbmRyb2lkLWxlc3Nvbi10d28tYW1iaWVudC1hbmQtZGlmZnVzZS1saWdodGluZy8=\"> Android 课程二：环境光和漫反射光</span></p>\n<h2 id=\"1什么是光\"><a class=\"anchor\" href=\"#1什么是光\">#</a> 1. 什么是光？</h2>\n<p>世界没有光就会什么也看不到，我们将无法感知这个世界活着物体。</p>\n<p>在真实的世界里，光是由无数的光子聚合在一起形成的，它从一个光源出发，经过无数时间，最后传递到了我们的眼睛里</p>\n<p>我们应该如何用计算机图像模拟光呢，现在有 2 种热门技术可以实现：光线跟踪和栅格化。光线跟踪通过数学计算跟踪真实的光线，能给出十分准确和真实的结果，但是不足之处是模拟所有的光线十分消耗计算资源，并且实时渲染速度很慢。由于这个限制，大多数的实时计算机图像使用的是栅格化技术，通过接近结果模拟光线。</p>\n<h2 id=\"2光线的分类\"><a class=\"anchor\" href=\"#2光线的分类\">#</a> 2. 光线的分类</h2>\n<p>我们可以抽象出光工作的方式形成三种基本的光线类型</p>\n<ul>\n<li>环境光</li>\n</ul>\n<p>环境光是一种基础的光线，它遍布整个场景，它没有表现出来自任何其他的光源，因为它在到达你之前经过了无数的反射。这种光能阴天的户外，或是许多不同光源累积影响的室内。没有分别计算所有独立的光，我们可以为对象或场景设置一个基本的光照等级。</p>\n<ul>\n<li>漫反射光</li>\n</ul>\n<p>这种光在到达教你的眼睛里经过了物体之间反射。物体的光照等级随它与光线的角度不同而变化。直面它的时候更加明亮。同样我们感知物体时无论我们相对物体的位置在哪里，亮点都是相同的。这种现象也叫兰伯特余弦定律（Lambert's cosine law），漫反射和兰伯特反射在生活中是很常见的。</p>\n<ul>\n<li>高光</li>\n</ul>\n<p>和漫反射不同，高光随我们和物体的位置不同而不同，它让物体发亮和更加光滑</p>\n<h2 id=\"2模拟光\"><a class=\"anchor\" href=\"#2模拟光\">#</a> 2. 模拟光</h2>\n<p>与在 3D 场景中的光有 3 种一样，光源也有 3 种：直接光源、Point lighting、Spot lighting。</p>\n<h3 id=\"1数学\"><a class=\"anchor\" href=\"#1数学\">#</a> 1. 数学</h3>\n<p>学习来自一个点光源的环境光和漫反射光</p>\n<h4 id=\"环境光\"><a class=\"anchor\" href=\"#环境光\">#</a> 环境光</h4>\n<p>环境光其实是漫反射光的一种，但是它也能被看作是充满整个场景的低级光。这样想的话，它会很容易计算</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">final color = material color * ambient light color</span><br></pre></td></tr></table></figure><br />\n 例如，有个物体是红色的，我们的环境光是灰白的。让我们假定将颜色存储为有 3 个颜色的数组红、绿、蓝，使用 RGB 颜色模型：</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">final color = &#123; 1 , 0 , 0 &#125; * &#123; 0.1 , 0.1 , 0.1 &#125; = &#123; 0.1 , 0.0 , 0.0 &#125;</span><br></pre></td></tr></table></figure></p>\n<p>最终物体的颜色会是淡红色。基础的场景光就是这样的，除非你想要更加高级的视觉技术</p>\n<h4 id=\"漫反射光-点光源\"><a class=\"anchor\" href=\"#漫反射光-点光源\">#</a> 漫反射光 - 点光源</h4>\n<p>对漫反射光，我们需要增加衰减和光的位置。光的位置会用来计算光和表面的角度，它会影响表面的光照的整个等级。它还用来计算光和表面的距离，并决定了那个点的光照强度。</p>\n<p><em>步骤一： 计算兰伯特因子</em></p>\n<p>我们需要的第一个主要的计算是计算出表明和光的角度。直面光线的表层会处于光照的最大强度。计算出这个属性的合适的方式是使用兰伯特余弦定理。如果我们有 2 个向量，一个是从光线到表面的一个点，第二个是曲面法线，我们可以计算出余弦值：先将各个向量归一化，因此有它们的长度为 1，然后计算出 2 个向量的点积。这个操作能通过 OpenGL ES 的两个着色器轻松完成。</p>\n<p>我们声明 lambert 因子，它的范围是 0 到 1</p>\n<ol>\n<li></li>\n</ol>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">light vector = light position - obejct position</span><br><span class=\"line\">cosine = dot product(object normal,normalize(light vector))</span><br><span class=\"line\">lambert factor = max(cosine,0)</span><br></pre></td></tr></table></figure><br />\n 首先我们通过对象位置减去光线位置计算出光线的向量，然后我们获取物体的法线和光线向量的点积，就得到了这个余弦了。归一化光线向量的意思就是改变它的长度为 1。因为点积德范围是 - 1 到 1，我们把它固定到（0，1）。</p>\n<p>这是一个例子：有个光滑的平面，表面的法线笔直的指向天。光线的位置为「0，10，-10」，或是向上 10 个单位，向前 10 个单位，我们要计算出原地的光</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">light vector = &#123; 0, 10, -10&#125; - &#123;0, 0, 0&#125; = &#123;0, 10, -10&#125;</span><br><span class=\"line\">obejct normal = &#123;0, 1, 0&#125;</span><br></pre></td></tr></table></figure><br />\n 用平白的语言来说，如果我们沿着光线向量出发移动，到达光线的位置。要归一化这个向量，我们让向量的每一个标量处以向量的长度：</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">light vector length = square root( 0*0 + 10*10 + -10*-10) = square root(200) = 14.14</span><br><span class=\"line\">normalized light vector = &#123;0/14.14, 10/14.14, -10/14.14&#125; = &#123;0, 0.707, -0.707&#125;</span><br></pre></td></tr></table></figure><br />\n 然后我们计算点积</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dot product(&#123;0,1,0&#125;,&#123;0,0.707, -0.707&#125;) = 0*0 + 1*0.707 + 0*-0.707 = 0.707</span><br><span class=\"line\">lambert factor = max(0.707,0) = 0.707</span><br></pre></td></tr></table></figure></p>\n<p>OpenGL ES 2 的着色器语言已经内置了一些这种函数，所以我们不需要手动做所有的数学，但是这对我们的理解仍然有帮助。</p>\n<p><em>步骤二：计算衰减因子</em></p>\n<p>接着，我们需要计算衰减，真实的点光源的光线衰减遵从<span class=\"exturl\" data-url=\"aHR0cDovL2JhaWtlLmJhaWR1LmNvbS9saW5rP3VybD1fa2RXcG5oNXJJVnZ0Y0tlQU1wZGRsWkdKUDJlNjVCM2V2cGQ4QS1mVFA0UFpqTG9RN09PdHpqQXJURHpWdmVMUEt2UllvaUxnQjJZSXdyTmswVVp3V3FQbHVsdnF4VjdKcjF0dXltZ3Y0eDhKS21hSVJpbGhKc0dxN1JuMmRFOHRHOHY3bFFtTnQ1aGVFRXExdDhrRUs=\">平方反比定律</span>，它可以表述为：<br />\n <code>luminosity = 1 / (distance* distance)</code> <br />\n 回到我们的例子，我们知道了一个距离为 14.14，所以最后我们的亮度看起来是：<br />\n <code>luminosity = 1/ (14.14*14.14) = 0.005</code> <br />\n 你可以看到，平方反比定律在距离上会导致剧烈的衰减。这就是光在真实世界中从点光源出发是怎么回事，但是我们的图像显示有限制范围，因此抑制衰减因子，我们能得到更加真实的光照而不会使物体看起来太暗了。</p>\n<p><em>步骤三：计算最后的颜色</em></p>\n<p>现在我们同时有了余弦和衰减因子，我们能计算出最终的光照等级：</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">final color = meterial color * (light color * lambert factor * luminosity)</span><br></pre></td></tr></table></figure></p>\n<p>回到之前一个例子，我们有红色的材料和全白的光源，最终的计算：</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">final color = &#123;1, 0, 0&#125; *(&#123;1,1,1&#125;*0.707*0.005) </span><br><span class=\"line\">= &#123;1,0,0&#125;*&#123;0.0035,0.0035,0.0035&#125; </span><br><span class=\"line\">= &#123;0.0035,0,0&#125;</span><br></pre></td></tr></table></figure></p>\n<p>简单的总结一下，对漫反射光我们需要使用表面和光线的角度，还有表面和光线的距离来最终计算出整个漫反射照明等级。下面是步骤：</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//one</span><br><span class=\"line\">light vector = light position - object position</span><br><span class=\"line\">cosine = dot product(object normal,normalize(light vector))</span><br><span class=\"line\">lambert factor = max(cosine,0)</span><br><span class=\"line\"></span><br><span class=\"line\">//two</span><br><span class=\"line\">luminosity = 1/(distance*distance)</span><br><span class=\"line\"></span><br><span class=\"line\">//three</span><br><span class=\"line\">final color = material color * (light\u0010 color*lambert factor * luminosity)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"顶点着色器\"><a class=\"anchor\" href=\"#顶点着色器\">#</a> 顶点着色器</h4>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">final String vertexShader =</span><br><span class=\"line\">    &quot;uniform mat4 u_MVPMatrix;      \\n&quot;     // 一个表示进行了Model变换、View变换、投影变换的矩阵</span><br><span class=\"line\">  + &quot;uniform mat4 u_MVMatrix;       \\n&quot;     // 一个表示进行了Model变换和View变换的矩阵</span><br><span class=\"line\">  + &quot;uniform vec3 u_LightPos;       \\n&quot;     // 在眼坐标系中光的位置</span><br><span class=\"line\"> </span><br><span class=\"line\">  + &quot;attribute vec4 a_Position;     \\n&quot;     // 传入的顶点位置信息</span><br><span class=\"line\">  + &quot;attribute vec4 a_Color;        \\n&quot;     // 传人的每个顶点的颜色信息</span><br><span class=\"line\">  + &quot;attribute vec3 a_Normal;       \\n&quot;     // 每个顶点的法线信息</span><br><span class=\"line\"> </span><br><span class=\"line\">  + &quot;varying vec4 v_Color;          \\n&quot;     // 颜色信息，这个变量会传递进片段着色器中</span><br><span class=\"line\"> </span><br><span class=\"line\">  + &quot;void main()                    \\n&quot;     </span><br><span class=\"line\">  + &quot;&#123;                              \\n&quot;</span><br><span class=\"line\">// 将顶点转化为眼坐标系</span><br><span class=\"line\">  + &quot;   vec3 modelViewVertex = vec3(u_MVMatrix * a_Position);              \\n&quot;</span><br><span class=\"line\">// 将法线方向转移进眼坐标系</span><br><span class=\"line\">  + &quot;   vec3 modelViewNormal = vec3(u_MVMatrix * vec4(a_Normal, 0.0));     \\n&quot;</span><br><span class=\"line\">// 计算出顶点和光线的距离  </span><br><span class=\"line\">  + &quot;   float distance = length(u_LightPos - modelViewVertex);             \\n&quot;</span><br><span class=\"line\">// 获取从光线处到顶点的光线向量</span><br><span class=\"line\">  + &quot;   vec3 lightVector = normalize(u_LightPos - modelViewVertex);        \\n&quot;</span><br><span class=\"line\">// 计算lambert factor，也就是计算光线向量和顶点法线的点积. 如果法线向量和光线向量指向同一个方向，则会得出最大的光照强度.</span><br><span class=\"line\">  + &quot;   float lambert = max(dot(modelViewNormal, lightVector), 0.1);       \\n&quot;</span><br><span class=\"line\">// 光线随距离的衰减</span><br><span class=\"line\">  + &quot;   float diffuse = lambert * (1.0 / (1.0 + (0.25 * distance * distance)));  \\n&quot;</span><br><span class=\"line\">// 将颜色乘以衰减度， It will be interpolated across the triangle.</span><br><span class=\"line\">  + &quot;   v_Color = a_Color * diffuse;                                       \\n&quot;</span><br><span class=\"line\">// gl_Position 存储最终的位置.</span><br><span class=\"line\">// 将这个向量乘以变换矩阵得到在归一屏幕坐标系中的点</span><br><span class=\"line\">  + &quot;   gl_Position = u_MVPMatrix * a_Position;                            \\n&quot;</span><br><span class=\"line\">  + &quot;&#125;                                                                     \\n&quot;;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"片段着色器\"><a class=\"anchor\" href=\"#片段着色器\">#</a> 片段着色器</h4>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">final String fragmentShader =</span><br><span class=\"line\">  &quot;precision mediump float;       \\n&quot;     // Set the default precision to medium. We don&#x27;t need as high of a</span><br><span class=\"line\">                                          // precision in the fragment shader.</span><br><span class=\"line\">+ &quot;varying vec4 v_Color;          \\n&quot;     // This is the color from the vertex shader interpolated across the</span><br><span class=\"line\">                                          // triangle per fragment.</span><br><span class=\"line\">+ &quot;void main()                    \\n&quot;     // The entry point for our fragment shader.</span><br><span class=\"line\">+ &quot;&#123;                              \\n&quot;</span><br><span class=\"line\">+ &quot;   gl_FragColor = v_Color;     \\n&quot;     // Pass the color directly through the pipeline.</span><br><span class=\"line\">+ &quot;&#125;                              \\n&quot;;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"光源的顶点-片段着色器\"><a class=\"anchor\" href=\"#光源的顶点-片段着色器\">#</a> 光源的顶点、片段着色器</h4>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Define a simple shader program for our point.</span><br><span class=\"line\">final String pointVertexShader =</span><br><span class=\"line\">    &quot;uniform mat4 u_MVPMatrix;      \\n&quot;</span><br><span class=\"line\">  + &quot;attribute vec4 a_Position;     \\n&quot;</span><br><span class=\"line\">  + &quot;void main()                    \\n&quot;</span><br><span class=\"line\">  + &quot;&#123;                              \\n&quot;</span><br><span class=\"line\">  + &quot;   gl_Position = u_MVPMatrix   \\n&quot;</span><br><span class=\"line\">  + &quot;               * a_Position;   \\n&quot;</span><br><span class=\"line\">  + &quot;   gl_PointSize = 5.0;         \\n&quot;</span><br><span class=\"line\">  + &quot;&#125;                              \\n&quot;;</span><br><span class=\"line\"> </span><br><span class=\"line\">final String pointFragmentShader =</span><br><span class=\"line\">    &quot;precision mediump float;       \\n&quot;</span><br><span class=\"line\">  + &quot;void main()                    \\n&quot;</span><br><span class=\"line\">  + &quot;&#123;                              \\n&quot;</span><br><span class=\"line\">  + &quot;   gl_FragColor = vec4(1.0,    \\n&quot; //直接指定片段颜色为白色</span><br><span class=\"line\">  + &quot;   1.0, 1.0, 1.0);             \\n&quot;</span><br><span class=\"line\">  + &quot;&#125;                              \\n&quot;;</span><br></pre></td></tr></table></figure></p>\n<p>有一个新的属性叫 <code>gl_PointSize</code>  是点在空间中的大小为多少个像素。</p>\n",
            "tags": [
                "图像处理",
                "OpenGL ES",
                "OpenGL ES2.0"
            ]
        }
    ]
}